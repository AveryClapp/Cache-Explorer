#!/bin/bash
set -e
set +m  # Disable job control to suppress initialization warnings in sandboxed environments

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
BACKEND_DIR="$(dirname "$SCRIPT_DIR")"
PROJECT_ROOT="$(dirname "$BACKEND_DIR")"

# Support both build layouts:
# 1. Top-level build/ directory (cmake from project root)
# 2. Per-component build/ directories (legacy)
if [[ -f "$PROJECT_ROOT/build/backend/llvm-pass/CacheProfiler.so" ]]; then
  PASS="$PROJECT_ROOT/build/backend/llvm-pass/CacheProfiler.so"
  RUNTIME="$PROJECT_ROOT/build/backend/runtime/libcache-explorer-rt.a"
  CACHE_SIM="$PROJECT_ROOT/build/backend/cache-simulator/cache-sim"
else
  PASS="$BACKEND_DIR/llvm-pass/build/CacheProfiler.so"
  RUNTIME="$BACKEND_DIR/runtime/build/libcache-explorer-rt.a"
  CACHE_SIM="$BACKEND_DIR/cache-simulator/build/cache-sim"
fi
RUNTIME_INC="$BACKEND_DIR/runtime"
CMAKE_MODULE="$BACKEND_DIR/integration/cmake"

# Export for subcommands
export CACHE_EXPLORER_PATH="$BACKEND_DIR"
export CACHE_EXPLORER_PASS="$PASS"
export CACHE_EXPLORER_RUNTIME="$RUNTIME"
export CACHE_EXPLORER_SIM="$CACHE_SIM"

main_usage() {
  echo "Cache Explorer - Visualize CPU cache behavior"
  echo ""
  echo "Usage: cache-explore <command> [options]"
  echo ""
  echo "Commands:"
  echo "  <source.c|cpp>    Compile and analyze a single source file"
  echo "  run <binary>      Analyze an already-instrumented binary"
  echo "  cmake <path>      Configure a CMake project with profiling"
  echo "  make <target>     Build and analyze a Makefile target"
  echo "  compare           Compare cache behavior across configs"
  echo "  report            Generate HTML report from analysis"
  echo "  cc/c++            Compiler wrapper for build system integration"
  echo ""
  echo "Examples:"
  echo "  cache-explore matrix.c --config educational"
  echo "  cache-explore run ./my_program --json"
  echo "  cache-explore cmake /path/to/project -DCMAKE_BUILD_TYPE=Release"
  echo "  cache-explore compare matrix.c --configs intel,amd,apple"
  echo ""
  echo "Run 'cache-explore <command> --help' for command-specific help."
}

# Check if first arg is a subcommand
if [[ $# -eq 0 ]]; then
  main_usage
  exit 0
fi

case "$1" in
  run)
    shift
    exec "$SCRIPT_DIR/cache-explore-run" "$@"
    ;;
  cmake)
    shift
    exec "$SCRIPT_DIR/cache-explore-cmake" "$@"
    ;;
  make)
    shift
    exec "$SCRIPT_DIR/cache-explore-make" "$@"
    ;;
  compare)
    shift
    exec "$SCRIPT_DIR/cache-explore-compare" "$@"
    ;;
  report)
    shift
    exec "$SCRIPT_DIR/cache-explore-report" "$@"
    ;;
  cc)
    shift
    exec "$SCRIPT_DIR/cache-explore-cc" "$@"
    ;;
  c++)
    shift
    exec "$SCRIPT_DIR/cache-explore-cxx" "$@"
    ;;
  --help|-h)
    main_usage
    exit 0
    ;;
esac

# Default: compile and analyze a source file
CONFIG="intel"
VERBOSE=""
KEEP_BINARY=""
JSON_OUTPUT=""
STREAM_OUTPUT=""
INPUT_FILE=""
DEFINES=()  # Array of -D flags
INCLUDES=() # Array of -I flags
SAMPLE_RATE=""
EVENT_LIMIT=""
PREFETCH=""
PREFETCH_DEGREE=""
COMPILER_PATH=""  # Path to LLVM bin directory (e.g., /opt/homebrew/opt/llvm@20/bin)
MULTI_FILE=""  # Flag to enable multi-file compilation

usage() {
  echo "Usage: cache-explore [options] <source.c|.cpp|.rs>"
  echo ""
  echo "Compile, instrument, run, and analyze cache behavior."
  echo "Supports C, C++, and Rust source files."
  echo ""
  echo "Options:"
  echo "  --config <name>   Cache config: intel|intel14|xeon|amd|zen3|epyc|"
  echo "                    apple|m2|m3|graviton|rpi4|embedded|educational"
  echo "  --verbose         Show each cache event"
  echo "  --keep            Keep the instrumented binary"
  echo "  --json            Output JSON format"
  echo "  --stream          Stream events in real-time (for WebSocket)"
  echo "  --multi-file      Compile all .c/.cpp files in the same directory"
  echo "  --sample <N>      Sample 1 in N events (e.g., 100 = 1% sampling)"
  echo "  --limit <N>       Stop after N events (e.g., 1000000 = 1M events max)"
  echo "  --prefetch <type> Enable prefetching: none|next|stream|stride|adaptive|intel"
  echo "  --prefetch-degree <N>  How many lines to prefetch ahead (default: 4)"
  echo "  --compiler <path> Path to LLVM bin directory (e.g., /opt/homebrew/opt/llvm@20/bin)"
  echo "  -O<level>         Optimization level (default: -O0)"
  echo "  -D <name>=<val>   Preprocessor define (can be used multiple times)"
  echo "  --help            Show this help"
  echo ""
  echo "Examples:"
  echo "  cache-explore matrix.c --config educational --verbose"
  echo "  cache-explore vector.cpp -O2 --json"
  echo "  cache-explore matrix.c -D N=1000 -D DEBUG"
  echo "  cache-explore bigprogram.c --sample 100 --limit 1000000"
  echo "  cache-explore main.c --multi-file --json   # Compile with all .c files in dir"
}

OPT_LEVEL="-O0"
INPUT_FILES=()  # Array to collect multiple input files

while [[ $# -gt 0 ]]; do
  case "$1" in
    --config) CONFIG="$2"; shift 2 ;;
    --verbose) VERBOSE="--verbose"; shift ;;
    --keep) KEEP_BINARY="1"; shift ;;
    --json) JSON_OUTPUT="--json"; shift ;;
    --stream) STREAM_OUTPUT="--stream"; shift ;;
    --multi-file) MULTI_FILE="1"; shift ;;
    --sample) SAMPLE_RATE="$2"; shift 2 ;;
    --limit) EVENT_LIMIT="$2"; shift 2 ;;
    --prefetch) PREFETCH="$2"; shift 2 ;;
    --prefetch-degree) PREFETCH_DEGREE="$2"; shift 2 ;;
    --compiler) COMPILER_PATH="$2"; shift 2 ;;
    -O*) OPT_LEVEL="$1"; shift ;;
    -D) DEFINES+=("-D$2"); shift 2 ;;
    -D*) DEFINES+=("$1"); shift ;;
    -I) INCLUDES+=("-I$2"); shift 2 ;;
    -I*) INCLUDES+=("$1"); shift ;;
    --help) usage; exit 0 ;;
    -*) echo "Unknown option: $1"; usage; exit 1 ;;
    *) INPUT_FILES+=("$1"); shift ;;
  esac
done

# For backwards compatibility, set INPUT_FILE to first file
INPUT_FILE="${INPUT_FILES[0]:-}"

if [[ -z "$INPUT_FILE" ]]; then
  echo "Error: No input file specified"
  usage
  exit 1
fi

if [[ ! -f "$INPUT_FILE" ]]; then
  echo "Error: File not found: $INPUT_FILE"
  exit 1
fi

# Check dependencies
if [[ ! -f "$PASS" ]]; then
  echo "Error: LLVM pass not built. Run: ./scripts/build.sh"
  exit 1
fi

if [[ ! -f "$RUNTIME" ]]; then
  echo "Error: Runtime not built. Run: ./scripts/build.sh"
  exit 1
fi

if [[ ! -f "$CACHE_SIM" ]]; then
  echo "Error: Cache simulator not built. Run: ./scripts/build.sh"
  exit 1
fi

# Find clang - prefer --compiler flag, then env, then versioned (CI), then unversioned (local)
find_clang() {
  # Check --compiler flag (path to LLVM bin directory)
  if [[ -n "$COMPILER_PATH" && -x "$COMPILER_PATH/clang" ]]; then
    echo "$COMPILER_PATH/clang"
    return
  fi
  # Check environment override
  if [[ -n "${CACHE_EXPLORER_CC:-}" ]]; then
    echo "$CACHE_EXPLORER_CC"
    return
  fi
  # Check for clang (macOS homebrew, PATH)
  if command -v clang &>/dev/null; then
    echo "clang"
    return
  fi
  # Check for versioned clang (Ubuntu CI)
  for ver in 21 20 19 18 17 16 15; do
    if command -v "clang-$ver" &>/dev/null; then
      echo "clang-$ver"
      return
    fi
  done
  echo "clang"  # fallback
}

find_clangxx() {
  # Check --compiler flag (path to LLVM bin directory)
  if [[ -n "$COMPILER_PATH" && -x "$COMPILER_PATH/clang++" ]]; then
    echo "$COMPILER_PATH/clang++"
    return
  fi
  if [[ -n "${CACHE_EXPLORER_CXX:-}" ]]; then
    echo "$CACHE_EXPLORER_CXX"
    return
  fi
  if command -v clang++ &>/dev/null; then
    echo "clang++"
    return
  fi
  for ver in 21 20 19 18 17 16 15; do
    if command -v "clang++-$ver" &>/dev/null; then
      echo "clang++-$ver"
      return
    fi
  done
  echo "clang++"
}

# Detect language from file extension
EXT="${INPUT_FILE##*.}"
case "$EXT" in
  c)
    LANG="c"
    COMPILER="$(find_clang)"
    BASENAME=$(basename "$INPUT_FILE" .c)
    ;;
  cpp|cc|cxx|C)
    LANG="c++"
    COMPILER="$(find_clangxx)"
    BASENAME=$(basename "$INPUT_FILE" ."$EXT")
    ;;
  rs)
    LANG="rust"
    COMPILER="rustc"
    BASENAME=$(basename "$INPUT_FILE" .rs)
    ;;
  *)
    echo "Error: Unsupported file extension: .$EXT"
    echo "Supported: .c, .cpp, .cc, .cxx, .rs"
    exit 1
    ;;
esac

BINARY="/tmp/cache-explore-$$-$BASENAME"

if [[ -z "$JSON_OUTPUT" ]]; then
  echo "=== Cache Explorer ===" >&2
  echo "Input: $INPUT_FILE" >&2
  echo "Language: $LANG" >&2
  echo "Config: $CONFIG" >&2
  echo "" >&2
  echo "[1/3] Compiling with instrumentation..." >&2
fi

EXTRA_FLAGS=""
if [[ "$OPT_LEVEL" == "-O0" ]]; then
  EXTRA_FLAGS="-Xclang -disable-O0-optnone"
fi

# Get the input directory
INPUT_DIR="$(dirname "$INPUT_FILE")"

# Collect source files
SOURCE_FILES=()

if [[ ${#INPUT_FILES[@]} -gt 1 ]]; then
  # Multiple files explicitly passed on command line
  SOURCE_FILES=("${INPUT_FILES[@]}")
elif [[ -n "$MULTI_FILE" ]]; then
  # Explicit multi-file mode: collect all source files from the directory
  for file in "$INPUT_DIR"/*.c "$INPUT_DIR"/*.cpp "$INPUT_DIR"/*.cc "$INPUT_DIR"/*.cxx; do
    [[ -e "$file" ]] && SOURCE_FILES+=("$file")
  done
else
  # Auto-detect multi-file mode: if the directory contains multiple .c files
  # and looks like a temp directory (created by the server), enable it automatically
  c_file_count=$(shopt -s nullglob; files=("$INPUT_DIR"/*.c); echo ${#files[@]})
  if [[ $c_file_count -gt 1 ]] && [[ "$INPUT_DIR" =~ ^/tmp/cache-explorer- ]]; then
    # Auto-enable multi-file mode for temp directories with multiple .c files
    for file in "$INPUT_DIR"/*.c "$INPUT_DIR"/*.cpp "$INPUT_DIR"/*.cc "$INPUT_DIR"/*.cxx; do
      [[ -e "$file" ]] && SOURCE_FILES+=("$file")
    done
  fi
fi

# Fallback: if no source files collected, just use the input file
if [[ ${#SOURCE_FILES[@]} -eq 0 ]]; then
  SOURCE_FILES=("$INPUT_FILE")
fi

# Compile based on language
if [[ "$LANG" == "rust" ]]; then
  # Rust compilation with LLVM pass
  # Note: Rust support requires rustc with LLVM pass plugin support
  if ! rustc --edition 2021 -C opt-level=0 -g \
    -C llvm-args=-load="$PASS" \
    -L "$BACKEND_DIR/runtime/build" \
    -l static=cache-explorer-rt \
    "$INPUT_FILE" \
    -o "$BINARY" 2>/tmp/cache-explore-compile-err-$$; then
    if [[ -n "$JSON_OUTPUT" ]]; then
      # Properly escape JSON: preserve newlines as \n, escape quotes
      ESCAPED=$(cat /tmp/cache-explore-compile-err-$$ | python3 -c "import sys,json; print(json.dumps(sys.stdin.read())[1:-1])")
      echo "{\"error\": \"Compilation failed\", \"details\": \"$ESCAPED\"}"
    else
      echo "Compilation failed:" >&2
      cat /tmp/cache-explore-compile-err-$$ >&2
    fi
    rm -f /tmp/cache-explore-compile-err-$$
    exit 1
  fi
elif ! $COMPILER $OPT_LEVEL $EXTRA_FLAGS -g -fpass-plugin="$PASS" \
  -I"$RUNTIME_INC" \
  "${INCLUDES[@]}" \
  "${DEFINES[@]}" \
  "${SOURCE_FILES[@]}" \
  "$RUNTIME" \
  -o "$BINARY" 2>/tmp/cache-explore-compile-err-$$; then
  if [[ -n "$JSON_OUTPUT" ]]; then
    # Properly escape JSON: preserve newlines as \n, escape quotes
    ESCAPED=$(cat /tmp/cache-explore-compile-err-$$ | python3 -c "import sys,json; print(json.dumps(sys.stdin.read())[1:-1])")
    echo "{\"error\": \"Compilation failed\", \"details\": \"$ESCAPED\"}"
  else
    echo "Compilation failed:" >&2
    cat /tmp/cache-explore-compile-err-$$ >&2
  fi
  rm -f /tmp/cache-explore-compile-err-$$
  exit 1
fi
rm -f /tmp/cache-explore-compile-err-$$

if [[ -z "$JSON_OUTPUT" ]] && [[ -z "$STREAM_OUTPUT" ]]; then
  echo "[2/3] Running instrumented binary..." >&2
fi

# Build environment for runtime options
RUN_ENV=""
if [[ -n "$SAMPLE_RATE" ]]; then
  RUN_ENV="CACHE_EXPLORER_SAMPLE_RATE=$SAMPLE_RATE $RUN_ENV"
fi
if [[ -n "$EVENT_LIMIT" ]]; then
  RUN_ENV="CACHE_EXPLORER_MAX_EVENTS=$EVENT_LIMIT $RUN_ENV"
fi

# Build prefetch flags for cache-sim
PREFETCH_ARG=""
if [[ -n "$PREFETCH" ]]; then
  PREFETCH_ARG="--prefetch $PREFETCH"
  # Default to aggressive prefetching (4 lines) to match Intel hardware
  if [[ -n "$PREFETCH_DEGREE" ]]; then
    PREFETCH_ARG="$PREFETCH_ARG --prefetch-degree $PREFETCH_DEGREE"
  else
    PREFETCH_ARG="$PREFETCH_ARG --prefetch-degree 4"
  fi
fi

# Streaming mode: pipe directly for real-time output
if [[ -n "$STREAM_OUTPUT" ]]; then
  if [[ -n "$RUN_ENV" ]]; then
    env $RUN_ENV "$BINARY" 2>&1 | "$CACHE_SIM" --config "$CONFIG" $STREAM_OUTPUT $PREFETCH_ARG
  else
    "$BINARY" 2>&1 | "$CACHE_SIM" --config "$CONFIG" $STREAM_OUTPUT $PREFETCH_ARG
  fi
  EXIT_CODE=${PIPESTATUS[0]}
else
  # Batch mode: capture trace then process
  if [[ -n "$RUN_ENV" ]]; then
    TRACE=$(env $RUN_ENV "$BINARY" 2>&1) || true
  else
    TRACE=$("$BINARY" 2>&1) || true
  fi

  if [[ -z "$JSON_OUTPUT" ]]; then
    echo "[3/3] Analyzing cache behavior..." >&2
    echo ""
  fi

  echo "$TRACE" | "$CACHE_SIM" --config "$CONFIG" $VERBOSE $JSON_OUTPUT $PREFETCH_ARG
fi

# Cleanup
if [[ -z "$KEEP_BINARY" ]]; then
  rm -f "$BINARY"
fi
